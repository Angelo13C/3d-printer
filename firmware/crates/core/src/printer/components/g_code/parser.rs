//! This module contains utilities to convert strings (which could be read from the [`file system`]) to
//! executable [`G-code commands`].
//!
//! All the parsing is automatically generated by the `build.rs` script.
//!
//! [`G-code commands`]: commands
//! [`file system`]: super::super::file_system

use std::str::SplitWhitespace;

use parameters::identifier;

use super::{
	commands::*,
	parameters::{identifier::GCodeParameterIdentifier, value::*, *},
	GCodeCommand, *,
};
use crate::utils::measurement::distance::*;

/// Check the [`module's`] documentation.
///
/// [`module's`]: self
#[derive(Clone, Copy, Default)]
pub struct GCodeParser
{
	units: Units,
}

impl GCodeParser
{
	/// Parses a single line of G-code and returns the result.
	///
	/// # Examples
	/// ```
	/// # use firmware_core::{printer::components::{g_code::{*, parameters::*, commands::*, parser::*}, mock::*}, utils::measurement::distance::Distance};
	/// #
	/// let g_code_parser = GCodeParser::default();
	///
	/// assert_command(&g_code_parser, "G0 X50 Z20.1", G0 {
	/// 	x: Param::from(Distance::from_millimeters(50)),
	/// 	y: Param::from(None),
	/// 	z: Param::from(Distance::from_micrometers(20_100)),
	/// 	e: Param::from(None),
	/// 	feed_rate: Param::from(None)
	/// });
	///
	/// assert_command(&g_code_parser, "G1 Y0.5 Z-5.15 F4000.40", G1 {
	/// 	x: Param::from(None),
	/// 	y: Param::from(Distance::from_micrometers(500)),
	/// 	z: Param::from(Distance::from_micrometers(-5_150)),
	/// 	e: Param::from(None),
	/// 	feed_rate: Param::from(4000.40)
	/// });
	///
	/// assert_command(&g_code_parser, "M104 S60", M104 {
	/// 	target_temperature: Param::from(60),
	/// });
	///
	/// fn assert_command<C: GCodeCommand<MockPeripherals> + PartialEq + 'static>(g_code_parser: &GCodeParser, line: &'static str, expected_value: C)
	/// {
	/// 	if let GCodeLine::Command(result) = g_code_parser.parse_line::<'static, MockPeripherals>(line)
	/// 	{
	/// 		assert_eq!(result.as_any().downcast_ref::<C>().unwrap(), &expected_value);
	/// 	}
	/// 	else {
	/// 		panic!("Not a command");
	/// 	}
	/// }
	/// ```
	pub fn parse_line<'a, P: Peripherals>(&self, line: &'a str) -> GCodeLine<'a, P>
	{
		let mut line_without_comment = line;
		let mut comment_position = None;
		if let Some(semi_colon_position) = line.find(';')
		{
			line_without_comment = &line[0..semi_colon_position];
			comment_position = Some(semi_colon_position + 1);
		}

		let mut words = line_without_comment.split_whitespace();
		match words.next()
		{
			Some(command) => match parse::<P>(command, words, self.units)
			{
				Some(parsed_command) => match comment_position
				{
					Some(comment_position) => GCodeLine::CommandAndComment(parsed_command, &line[comment_position..]),
					None => GCodeLine::Command(parsed_command),
				},
				None => GCodeLine::Error,
			},
			None => match comment_position
			{
				Some(comment_position) => GCodeLine::Comment(&line[comment_position..]),
				None => GCodeLine::Empty,
			},
		}
	}
}

/// This enum is the result of parsing a line using [`GCodeParser`].
#[derive(Debug)]
pub enum GCodeLine<'a, P: Peripherals>
{
	/// An empty line.
	///
	/// # Examples
	/// ``` ```
	Empty,

	/// A line that contains only a command.
	///
	/// # Examples
	/// ```text
	/// G0 X40 Y20
	/// ```
	/// ```text
	/// M107
	/// ```
	Command(Box<dyn GCodeCommand<P>>),

	/// A line that contains only a comment.
	///
	/// # Examples
	/// ```text
	/// ;This is just a comment
	/// ```
	/// ```text
	/// ;3 hours
	/// ```
	Comment(&'a str),

	/// A line that contains both a command and a comment.
	///
	/// # Examples
	/// ```text
	/// G1 Y30;This is the comment
	/// ```
	CommandAndComment(Box<dyn GCodeCommand<P>>, &'a str),

	/// It may either be that the line contains a command that isn't supported by this firmware,
	/// or it may be an invalid gcode command in general.
	///
	/// # Examples
	/// ```text
	/// G9999
	/// ```
	/// ```text
	/// Something is wrong
	/// ```
	///
	/// [`parser`]: `super::parser::GCodeParser`
	Error,
}

/// **This function is generated at compile time by the build.rs file and you shouldn't touch it.**
fn parse<P: Peripherals>(command: &str, parameters: SplitWhitespace, units: Units) -> Option<Box<dyn GCodeCommand<P>>>
{
	use parameters::identifier::*;

	return include!(concat!(env!("OUT_DIR"), "/g_code_deserializer.rs"));
}

/// This function is used by [`parse`].
fn find_identifier<'a, I: GCodeParameterIdentifier>(words: SplitWhitespace<'a>) -> Option<(I, &'a str)>
{
	for word in words
	{
		let mut identifier = I::default();
		if let Ok(chars_count) = identifier.is_this(word)
		{
			return Some((identifier, &word[chars_count..]));
		}
	}

	None
}
